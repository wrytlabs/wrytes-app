import { useCallback } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { useAppKitAccount } from '@reown/appkit-controllers/react';
import { RootState, AppDispatch } from '@/redux/redux.store';
import {
  addTransactions,
  updateTransaction,
  removeTransaction,
  reorderTransactions,
  moveTransactionUp,
  moveTransactionDown,
  clearCompleted,
  clearAllTransactions,
  retryTransaction,
  bulkRemove,
  updateTransactionStatus,
  executeTransaction,
  executeBatch,
  executeAll,
  simulateTransaction,
} from '@/redux/slices/transactionQueue.slice';
import { QueueTransaction, TransactionStatus, TransactionQueueContextType, ExecutionResult } from '@/lib/transactions/types';

// --------------------------------------------------------------------------------
// Redux-based Transaction Queue Hook
// --------------------------------------------------------------------------------

export const useTransactionQueue = (): TransactionQueueContextType => {
  const dispatch = useDispatch<AppDispatch>();
  const { address: userAddress } = useAppKitAccount();
  
  // Select state from Redux store
  const transactions = useSelector((state: RootState) => state.transactionQueue.transactions);
  const activeTransactionId = useSelector((state: RootState) => state.transactionQueue.activeTransactionId);
  const isExecuting = useSelector((state: RootState) => state.transactionQueue.isExecuting);

  // --------------------------------------------------------------------------------
  // Transaction Management
  // --------------------------------------------------------------------------------

  const handleAddTransaction = useCallback(async (
    transactionData: Omit<QueueTransaction, 'id' | 'createdAt' | 'updatedAt' | 'status'>[] | Omit<QueueTransaction, 'id' | 'createdAt' | 'updatedAt' | 'status'>
  ): Promise<string[]> => {
    // Generate IDs for each transaction (will be generated in reducer)
    const transactionIds: string[] = [];
    
    // Normalize to array format
    const transactionsArray = Array.isArray(transactionData) ? transactionData : [transactionData];
    
    // Dispatch add action
    dispatch(addTransactions({ transactions: transactionsArray }));
    
    // Return the IDs of the newly added transactions
    // Note: In a real implementation, you might want to return the actual IDs generated by the reducer
    // For now, we'll return empty array as the reducer generates UUIDs internally
    return transactionIds;
  }, [dispatch]);

  const handleUpdateTransaction = useCallback(async (id: string, updates: Partial<QueueTransaction>) => {
    dispatch(updateTransaction({ id, updates }));
  }, [dispatch]);

  const handleRemoveTransaction = useCallback((id: string) => {
    dispatch(removeTransaction({ id }));
  }, [dispatch]);

  const handleRetryTransaction = useCallback((id: string) => {
    dispatch(retryTransaction({ id }));
  }, [dispatch]);

  const cancelTransaction = useCallback((id: string) => {
    dispatch(removeTransaction({ id }));
  }, [dispatch]);

  const handleClearCompleted = useCallback(() => {
    dispatch(clearCompleted());
  }, [dispatch]);

  // --------------------------------------------------------------------------------
  // Query Functions
  // --------------------------------------------------------------------------------

  const getTransactionById = useCallback((id: string) => {
    return transactions.find((tx: QueueTransaction) => tx.id === id);
  }, [transactions]);

  const getPendingCount = useCallback(() => {
    return transactions.filter((tx: QueueTransaction) => 
      tx.status === 'queued' || tx.status === 'pending' || tx.status === 'executing' || tx.status === 'failed'
    ).length;
  }, [transactions]);

  const getActiveTransaction = useCallback(() => {
    if (!activeTransactionId) return null;
    return getTransactionById(activeTransactionId) || null;
  }, [activeTransactionId, getTransactionById]);

  const getTransactionsByStatus = useCallback((status: TransactionStatus) => {
    return transactions.filter((tx: QueueTransaction) => tx.status === status);
  }, [transactions]);

  const getTransactionsByType = useCallback((type: string) => {
    return transactions.filter((tx: QueueTransaction) => tx.type === type);
  }, [transactions]);

  const getPendingTransactions = useCallback(() => {
    return transactions.filter((tx: QueueTransaction) => 
      tx.status === 'queued' || tx.status === 'pending' || tx.status === 'executing' || tx.status === 'failed'
    );
  }, [transactions]);

  // --------------------------------------------------------------------------------
  // Execution Functions
  // --------------------------------------------------------------------------------

  const handleExecuteTransaction = useCallback(async (id: string) => {
    if (!userAddress) {
      console.error('No user address available');
      return;
    }

    dispatch(executeTransaction({ id, userAddress: userAddress as `0x${string}` }));
  }, [dispatch, userAddress]);

  const handleExecuteBatch = useCallback(async (ids: string[]) => {
    if (!userAddress) {
      console.error('No user address available');
      return;
    }

    dispatch(executeBatch({ ids, userAddress: userAddress as `0x${string}` }));
  }, [dispatch, userAddress]);

  const handleExecuteAll = useCallback(async () => {
    if (!userAddress) {
      console.error('No user address available');
      return;
    }

    dispatch(executeAll({ userAddress: userAddress as `0x${string}` }));
  }, [dispatch, userAddress]);

  const handleSimulateTransaction = useCallback(async (id: string): Promise<ExecutionResult> => {
    if (!userAddress) {
      console.error('No user address available');
      return { success: false, error: 'No user address available' };
    }

    const result = await dispatch(simulateTransaction({ id, userAddress: userAddress as `0x${string}` }));
    return result.payload as ExecutionResult;
  }, [dispatch, userAddress]);

  // --------------------------------------------------------------------------------
  // Queue Management Functions
  // --------------------------------------------------------------------------------

  const handleMoveTransactionUp = useCallback((id: string) => {
    dispatch(moveTransactionUp(id));
  }, [dispatch]);

  const handleMoveTransactionDown = useCallback((id: string) => {
    dispatch(moveTransactionDown(id));
  }, [dispatch]);

  const handleReorderTransactions = useCallback((orderedIds: string[]) => {
    dispatch(reorderTransactions({ orderedIds }));
  }, [dispatch]);

  const handleClearAll = useCallback(() => {
    dispatch(clearAllTransactions());
  }, [dispatch]);

  const bulkExecute = useCallback(async (ids: string[]) => {
    await handleExecuteBatch(ids);
  }, [handleExecuteBatch]);

  const handleBulkRemove = useCallback((ids: string[]) => {
    dispatch(bulkRemove(ids));
  }, [dispatch]);

  // --------------------------------------------------------------------------------
  // Return the same interface as the original Context
  // --------------------------------------------------------------------------------

  return {
    transactions,
    activeTransactionId,
    addTransaction: handleAddTransaction,
    updateTransaction: handleUpdateTransaction,
    removeTransaction: handleRemoveTransaction,
    retryTransaction: handleRetryTransaction,
    cancelTransaction,
    clearCompleted: handleClearCompleted,
    getTransactionById,
    getPendingCount,
    getActiveTransaction,
    executeTransaction: handleExecuteTransaction,
    executeBatch: handleExecuteBatch,
    executeAll: handleExecuteAll,
    simulateTransaction: handleSimulateTransaction,
    isExecuting,
    // Queue management methods
    moveTransactionUp: handleMoveTransactionUp,
    moveTransactionDown: handleMoveTransactionDown,
    reorderTransactions: handleReorderTransactions,
    clearAll: handleClearAll,
    bulkExecute,
    bulkRemove: handleBulkRemove,
    // Enhanced querying
    getTransactionsByStatus,
    getTransactionsByType,
    getPendingTransactions,
  };
};

// --------------------------------------------------------------------------------
// Additional Redux Hooks for Specific Use Cases
// --------------------------------------------------------------------------------

// Hook to get just the transaction count
export const useTransactionCount = () => {
  return useSelector((state: RootState) => state.transactionQueue.transactions.length);
};

// Hook to get just the pending count
export const usePendingTransactionCount = () => {
  return useSelector((state: RootState) => {
    return state.transactionQueue.transactions.filter((tx: QueueTransaction) => 
      tx.status === 'queued' || tx.status === 'pending' || tx.status === 'executing' || tx.status === 'failed'
    ).length;
  });
};

// Hook to get execution status
export const useIsExecuting = () => {
  return useSelector((state: RootState) => state.transactionQueue.isExecuting);
};

// Hook to get active transaction
export const useActiveTransaction = () => {
  return useSelector((state: RootState) => {
    const { transactions, activeTransactionId } = state.transactionQueue;
    if (!activeTransactionId) return null;
    return transactions.find((tx: QueueTransaction) => tx.id === activeTransactionId) || null;
  });
};

// Hook for transaction status updates (useful for individual transaction components)
export const useTransactionStatusUpdate = () => {
  const dispatch = useDispatch<AppDispatch>();
  
  return useCallback((id: string, status: TransactionStatus, error?: string, txHash?: string) => {
    dispatch(updateTransactionStatus({ id, status, error, txHash }));
  }, [dispatch]);
};